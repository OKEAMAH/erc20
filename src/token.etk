;
; erc20
;
; Minimal ERC-20 implementation in raw assembly.
;
; Storage Layout
; --
; balance(address)	    => 0x000000000000000000000000 || address
; allowance(owner, spender) => keccak(owner || spender)


start:
	; Read the calldata into memory.
	calldatasize		; [calldatasize]
	push1 0			; [0, calldatasize]
	dup1			; [0, 0, calldatasize]
	calldatacopy		; []

	; Extract only the function selector
	push1 0			; [0]
	mload			; [dirty_selector]
	push1 224		; [224, dirty_selector]
	shr		      	; [selector]

	; Jump to the coresponding function.
	dup1			; [selector, selector]
	push4 selector("transferFrom(address,address,uint256)") ; [candidate, selector, selector]
	eq			; [success, selector]
	push4 transfer_from	; [transfer_from, success, selector]
	jumpi			; [selector]

	dup1			; [selector, selector]
	push4 selector("approve(address,uint256)") ; [candidate, selector, selector]
	eq			; [success, selector]
	push4 approve		; [allowance, success, selector]
	jumpi			; [selector]

	dup1			; [selector, selector]
	push4 selector("transfer(address,uint256)") ; [candidate, selector, selector]
	eq			; [selector, success]
	push4 transfer		; [transfer, success, selector]
	jumpi			; [selector]


	; Check the view functions last to not waste gas on-chain.
	dup1			; [selector, selector]
	push4 selector("decimals()") ; [candidate, selector, selector]
	eq			; [success, selector]
	push4 decimals		; [decimals, success, selector]
	jumpi			; [selector]

	dup1			; [selector, selector]
	push4 selector("totalSupply()")	; [candidate, selector, selector]
	eq			; [success, selector]
	push4 total_supply	; [total_supply, success, selector]
	jumpi			; [selector]

	dup1			; [selector, selector]
	push4 selector("balanceOf(address)") ; [candidate, selector, selector]
	eq			; [success, selector]
	push4 balance_of	; [balance_of, success, selector]
	jumpi			; [selector]

	dup1			; [selector, selector]
	push4 selector("allowance(address,address)") ; [candidate, selector, selector]
	eq			; [success, selector]
	push4 allowance		; [allowance, success, selector]
	jumpi			; [selector]


; Catchall for reverts.
failure:
	jumpdest
	push1 0
	push1 0
	revert

; balance_of
;
; calldata structure
; +--------------------+------------------+--------------------+
; | selector (4 bytes) | zeros (12 bytes) | address (20 bytes) |
; +--------------------+------------------+--------------------+

balance_of:
	jumpdest		; [selector]
	pop			; []

	; prepare return parameters
	push1 32		; [ret_len]
	push1 0			; [ret_offset, ret_len]

	; skip the selector, load the address
	push1 4			; [4, ret_offset, ret_len]
	mload			; [addr, ret_offset, ret_len]

	; load balance
	sload			; [balance, ret_offset, ret_len]

	; prepare balance to return
	dup2			; [0, balance, ret_offset, ret_len]
	mstore			; [ret_offset, ret_len]

	return			; []

; transfer
;
; calldata structure
; +--------------------+------------------+---------------+-------------------+
; | selector (4 bytes) | zeros (12 bytes) | to (20 bytes) | amount (32 bytes) |
; +--------------------+------------------+---------------+-------------------+
transfer:
	jumpdest
	pop

	caller			; [from]
	sload			; [from_balance]
	push1 36		; [36, from_balance]
	mload			; [amt, from_balance]
	dup2			; [from_balance, amt, from_balance]
	dup2			; [amt, from_balance, amt, from_balance]

	eq			; [amt == from_balance, amt, from_balance]
	push4 valid_transfer	; [continue, amt == from_balance, amt, from_balance]
	jumpi			; [amt, from_balance]

	dup2			; [from_balance, amt, from_balance]
	dup2			; [amt, from_balance, amt, from_balance]
	gt			; [amt > from_balance, amt, from_balance]
	push4 failure		; [failure, from_balance, amt, from_balance]
	jumpi			; [amt, from_balance]

valid_transfer:
	dup1			; [amt, amt, from_balance]
	swap2			; [from_balance, amt, amt]
	sub			; [from_balance - amt, amt]
	caller			; [from, from_balance - amt, amt]
	sstore			; [amt]
	push1 4			; [4, amt]
	mload			; [to, amt]
	dup1			; [to, to, amt]
	sload			; [to_balance, to, amt]
	swap1			; [to, to_balance, amt]
	swap2			; [amt, to_balance, to]
	add			; [amt + to_balance, to]
	swap1			; [to, amt + to_balance]
	sstore			; []

	stop

; approve
;
; calldata structure
; +--------------------+------------------+--------------------+-------------------+
; | selector (4 bytes) | zeros (12 bytes) | spender (20 bytes) | amount (32 bytes) |
; +--------------------+------------------+--------------------+-------------------+
approve:
	jumpdest		; []
	pop			; []
	push1 36		; [36]
	mload			; [amt]

	; write the caller to mem[36..68]
	caller			; [caller, amt]
	push1 36		; [36, caller, amt]
	mstore			; [amt]

	push1 64		; [len, amt]
	push1 4			; [offset, len, amt]
	keccak256		; [key, amt]
	dup1			; [key, key, amt]

	sload			; [allowance, key, amt]
	swap1			; [key, allowance, amt]
	swap2			; [amt, allowance, key]
	add			; [new_allowance, key]
	swap1			; [key, new_allowance]
	sstore			; []

	stop

; allowance
;
; calldata structure
; +--------------------+------------------+------------------+------------------+--------------------+
; | selector (4 bytes) | zeros (12 bytes) | owner (20 bytes) | zeros (20 bytes) | spender (20 bytes) |
; +--------------------+------------------+------------------+------------------+--------------------+
allowance:
	jumpdest		; []
	pop			; []

	; current order in memory is [owner, spender], but to calculate the
	; allowance key it needs to be [spender, owner]
	push1 4			; [offset]
	mload			; [owner]
	push1 68		; [offset, owner]
	mstore

	push1 64		; [len]
	push1 36		; [offset]
	keccak256		; [key]

	sload			; [allowance]
	push1 0			; [offset, allowance]
	mstore			; []

	push1 32		; [32]
	push1 0			; [0, 32]
	return			; []

decimals:
	jumpdest
total_supply:
	jumpdest
transfer_from:
	jumpdest

stop
